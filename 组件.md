## 组件的构造函数：
```js
var Sub = function VueComponent (options) {
    this._init(options);
};
Sub.prototype = Object.create(Super.prototype);
Sub.prototype.constructor = Sub;
Sub.cid = cid++;
Sub.options = mergeOptions(
        Super.options,
        extendOptions
    );
Sub['super'] = Super;

```

## 流程：
1. render读render函数到_c("my-component")
2. _createElement: 根据render函数创建vnode
3. createComponent：生成虚拟dom
    1. 从组件中传入的components参数拿到这个组件的构造函数
    2. 异步组件在render函数解析到_c的时候，不会创建完整的组件vnode，只会创建一个`createAsyncPlaceholder`占位用
    3. 给子组件data绑定上componentVNodeHooks（init、prepatch、insert、destroy）
    4. 创建组件vnode
        ```js
        var vnode = new VNode(
            ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
            data, undefined, undefined, undefined, context,
            { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
            asyncFactory
        );
        ```
4. _update阶段，添加组件的虚拟dom到真实dom上
5. createElm
6. createComponent: 用之前混入到vm.hook的componentVNodeHooks里的init初始化componentVNodeHooks.init()
    1. `vnode.componentInstance = createComponentInstanceForVnode()`
    2. `return new vnode.componentOptions.Ctor(options)`
    3. `vnode.componentInstance.$mount()`
7. initComponent,
7. 调用render函数的时候createComponent ,触发_update的时候调用二号createComponent

> 组件和其他元素的区别：vnode上有没有`componentInstance`

## 问题：
1. 异步组件的引入？
    1. 异步组件在render函数解析到_c的时候，不会创建完整的组件vnode，只会创建一个`createAsyncPlaceholder`占位用